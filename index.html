<!DOCTYPE html>
<html lang="tr">

<head>
  <meta charset="UTF-8" />
  <title>Harita ve Emoji Botlar + Mini Harita</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      font-family: Arial, sans-serif;
    }

    canvas {
      display: block;
      background: #222;
    }

    #miniMapContainer {
      position: fixed;
      top: 10px;
      left: 10px;
      background: #222c;
      border: 2px solid #555;
      width: 200px;
      height: 200px;
      box-sizing: border-box;
      z-index: 20;
    }

    #miniMap {
      width: 100%;
      height: 100%;
      display: block;
      background: #444;
    }

    #playerSizeDisplay {
      position: fixed;
      top: 220px;
      left: 10px;
      color: #eee;
      font-weight: bold;
      font-size: 18px;
      user-select: none;
      z-index: 20;
    }

    #restartButton {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #ff5555;
      color: white;
      font-size: 24px;
      font-weight: bold;
      padding: 20px 40px;
      border: none;
      border-radius: 10px;
      display: none;
      z-index: 100;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <canvas id="game"></canvas>

  <div id="miniMapContainer">
    <canvas id="miniMap"></canvas>
  </div>
  <div id="playerSizeDisplay"></div>
  <button id="restartButton" onclick="location.reload()">Kaybettin <br> Yeniden Başlat</button>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const miniMapCanvas = document.getElementById('miniMap');
    const miniCtx = miniMapCanvas.getContext('2d');
    miniMapCanvas.width = 200;
    miniMapCanvas.height = 200;

    const BASE_MAP_SIZE = 200000;
    const MAP_SCALE = 1;
    const MAP_WIDTH = BASE_MAP_SIZE * MAP_SCALE;
    const MAP_HEIGHT = BASE_MAP_SIZE * MAP_SCALE;


    const PLAYER_SPEED = 3;
    const BOT_SPEED = 3;

    const EMOJIS = [
      '😀', '😃', '😄', '😁', '😆', '😅', '😂', '🤣', '😊', '😇',
      '🙂', '🙃', '😉', '😌', '😍', '🥰', '😘', '😗', '😙', '😚',
      '😋', '😛', '😝', '😜', '🤪', '🤨', '🧐', '🤓', '😎', '🥳',
      '😏', '😒', '😞', '😔', '😟', '😕', '🙁', '☹️', '😣', '😖',
      '😫', '😩', '🥺', '😢', '😭', '😤', '😠', '😡', '🤬', '😶‍🌫️'
    ];

    const restartButton = document.getElementById('restartButton');

    const player = {
      x: MAP_WIDTH / 2,
      y: MAP_HEIGHT / 2,
      size: 30,
      color: 'lime',
      speed: PLAYER_SPEED,
      dx: 0,
      dy: 0,
      emoji: '😎'
    };

    const bots = [];
    function spawnBot() {
      return {
        x: Math.random() * MAP_WIDTH,
        y: Math.random() * MAP_HEIGHT,
        size: 30,
        color: getRandomColor(),
        dx: (Math.random() - 0.5) * BOT_SPEED * 2,
        dy: (Math.random() - 0.5) * BOT_SPEED * 2,
        alive: true,
        emoji: EMOJIS[Math.floor(Math.random() * EMOJIS.length)],
        name: 'Bot'
      };
    }

    function getRandomColor() {
      const letters = '0123456789ABCDEF';
      let color = '#';
      for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }

    for (let i = 0; i < 200; i++) { // Eski: 25
      bots.push(spawnBot());
    }


    const foods = [];
    function spawnFoods(count) {
      for (let i = 0; i < count; i++) {
        foods.push({
          x: Math.random() * MAP_WIDTH,
          y: Math.random() * MAP_HEIGHT,
          size: 8,
          color: 'yellow'
        });
      }
    }
    spawnFoods(5000);

    window.addEventListener('keydown', e => {
      if (e.key === 'ArrowUp') player.dy = -player.speed;
      if (e.key === 'ArrowDown') player.dy = player.speed;
      if (e.key === 'ArrowLeft') player.dx = -player.speed;
      if (e.key === 'ArrowRight') player.dx = player.speed;
    });
    window.addEventListener('keyup', e => {
      if (['ArrowUp', 'ArrowDown'].includes(e.key)) player.dy = 0;
      if (['ArrowLeft', 'ArrowRight'].includes(e.key)) player.dx = 0;
    });

    function drawCircle(entity, cameraX, cameraY, scale = 1) {
      const radius = entity.size * scale;

      ctx.beginPath();
      ctx.arc((entity.x - cameraX) * scale, (entity.y - cameraY) * scale, radius, 0, Math.PI * 2);
      ctx.fillStyle = entity.color;
      ctx.fill();

      if (entity.emoji) {
        ctx.font = `${radius * 1.5}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(entity.emoji, (entity.x - cameraX) * scale, (entity.y - cameraY) * scale);
      }
    }

    function drawFood(food, cameraX, cameraY, scale = 1) {
      ctx.beginPath();
      ctx.arc((food.x - cameraX) * scale, (food.y - cameraY) * scale, food.size * scale, 0, Math.PI * 2);
      ctx.fillStyle = food.color;
      ctx.fill();
    }

    function getDistance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function moveBot(bot) {
      if (!bot.alive) return;

      if (Math.random() < 0.02) {
        bot.dx = (Math.random() - 0.5) * BOT_SPEED * 2;
        bot.dy = (Math.random() - 0.5) * BOT_SPEED * 2;
      }

      let nearestFood = null;
      let minFoodDist = Infinity;
      for (let f of foods) {
        const dist = getDistance(bot, f);
        if (dist < minFoodDist) {
          minFoodDist = dist;
          nearestFood = f;
        }
      }

      for (let otherBot of bots) {
        if (otherBot === bot || !otherBot.alive) continue;
        const dist = getDistance(bot, otherBot);
        if (dist < minFoodDist && bot.size > otherBot.size + 5) {
          minFoodDist = dist;
          nearestFood = otherBot;
        }
      }

      if (nearestFood) {
        let angle = Math.atan2(nearestFood.y - bot.y, nearestFood.x - bot.x);
        bot.dx = Math.cos(angle) * BOT_SPEED;
        bot.dy = Math.sin(angle) * BOT_SPEED;
      }

      bot.x += bot.dx;
      bot.y += bot.dy;

      if (bot.x < bot.size) bot.x = bot.size;
      if (bot.y < bot.size) bot.y = bot.size;
      if (bot.x > MAP_WIDTH - bot.size) bot.x = MAP_WIDTH - bot.size;
      if (bot.y > MAP_HEIGHT - bot.size) bot.y = MAP_HEIGHT - bot.size;
    }

    function update() {
      player.x += player.dx;
      player.y += player.dy;
      player.x = Math.min(Math.max(player.size, player.x), MAP_WIDTH - player.size);
      player.y = Math.min(Math.max(player.size, player.y), MAP_HEIGHT - player.size);

      bots.forEach(moveBot);

      for (let i = foods.length - 1; i >= 0; i--) {
        if (getDistance(player, foods[i]) < player.size) {
          player.size += 5;
          foods.splice(i, 1);
        }
      }

      bots.forEach(bot => {
        if (!bot.alive) return;

        for (let i = foods.length - 1; i >= 0; i--) {
          if (getDistance(bot, foods[i]) < bot.size) {
            bot.size += 5;
            foods.splice(i, 1);
          }
        }

        for (let otherBot of bots) {
          if (otherBot === bot || !otherBot.alive) continue;
          const dist = getDistance(bot, otherBot);
          if (dist < bot.size && bot.size > otherBot.size + 5) {
            bot.size += otherBot.size / 2;
            killBot(otherBot);
          }
        }
      });

      for (let bot of bots) {
        if (!bot.alive) continue;
        const dist = getDistance(player, bot);
        if (dist < player.size && player.size > bot.size + 5) {
          player.size += bot.size / 2;
          killBot(bot);
        } else if (dist < bot.size && bot.size > player.size + 5) {
          restartButton.style.display = 'block'; // alert yerine buton göster
          cancelAnimationFrame(gameLoopId); // animasyonu durdur
          return;
        }
      }

      if (foods.length < 300) {
        spawnFoods(400);
      }
    }

    function killBot(bot) {
      bot.alive = false;
      setTimeout(() => {
        Object.assign(bot, spawnBot());
        bot.alive = true;
      }, 10000);
    }

    function getCameraScale() {
      const baseSize = 30;
      const size = player.size;
      const scale = 1 / Math.log2(size / baseSize + 1);
      return Math.max(0.03, scale);
    }

    function drawMiniMap() {
      miniCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

      miniCtx.fillStyle = '#222';
      miniCtx.fillRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

      const scaleX = miniMapCanvas.width / MAP_WIDTH;
      const scaleY = miniMapCanvas.height / MAP_HEIGHT;

      miniCtx.fillStyle = 'yellow';
      foods.forEach(food => {
        miniCtx.beginPath();
        miniCtx.arc(food.x * scaleX, food.y * scaleY, 1.5, 0, Math.PI * 2);
        miniCtx.fill();
      });

      bots.forEach(bot => {
        if (bot.alive) {
          miniCtx.fillStyle = bot.color;
          miniCtx.beginPath();
          miniCtx.arc(bot.x * scaleX, bot.y * scaleY, 3, 0, Math.PI * 2);
          miniCtx.fill();
        }
      });

      miniCtx.strokeStyle = 'white';
      miniCtx.lineWidth = 2;
      miniCtx.beginPath();
      miniCtx.arc(player.x * scaleX, player.y * scaleY, 5, 0, Math.PI * 2);
      miniCtx.stroke();

      const scale = getCameraScale();
      const camWidth = miniMapCanvas.width / scale;
      const camHeight = miniMapCanvas.height / scale;

      let camX = player.x - (canvas.width / (2 * scale));
      let camY = player.y - (canvas.height / (2 * scale));

      camX *= scaleX;
      camY *= scaleY;

      miniCtx.strokeStyle = 'white';
      miniCtx.lineWidth = 1;
      miniCtx.strokeRect(camX, camY, camWidth * scaleX, camHeight * scaleY);
    }

    let gameLoopId;
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      update();

      const scale = getCameraScale();
      const cameraX = player.x - canvas.width / (2 * scale);
      const cameraY = player.y - canvas.height / (2 * scale);

      ctx.save();
      ctx.scale(scale, scale);
      ctx.translate(-cameraX, -cameraY);

      ctx.fillStyle = '#444';
      ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);

      foods.forEach(food => drawFood(food, 0, 0));

      bots.forEach(bot => {
        if (bot.alive) drawCircle(bot, 0, 0);
      });

      drawCircle(player, 0, 0);

      ctx.restore();

      drawMiniMap();

      document.getElementById('playerSizeDisplay').textContent = `Hacmin: ${Math.round(player.size)} px`;

      gameLoopId = requestAnimationFrame(gameLoop);
    }

    gameLoop();

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>

</html>